Comando para escolher a PASTA a partir da qual o servidor PHP vai se iniciar:
    php -S localhost:8080 -t public

O parâmetro -S (maiúsculo) abre o servidor web do PHP. 
O parâmetro -t (minúsculo) definte o caminho target para os arquivos do PHP.

O projeto inicial no composer.json não continha as seguintes dependências, as 
quais foram necessárias para rodar o projeto baixado: 
    symfony/cache
    doctrine/annotations

*** Ponto único de entrada ***
Por padrão, se um caminho sem extensão for procurado no navegador, o servidor 
PHP retorna o arquivo index.php (ou qualquer arquivo definido como padrão pelo 
servidor web). Se você solicitar um arquivo com a extensão .php, o servidor 
retorna o arquivo .php ou a mensagem de erro caso não encontre o arquivo.

O benefício de o servidor buscar o index a partir de uma URI indisponível é
que esse índice pode buscar páginas a partir dessa URI. Com um ponto único de 
entrada, podemos filtrar todas as requisições e até realizar logs se quisermos.

A variável global $_SERVER é um array que contém o caminho da URI solicitada.
No PHP 7 o nome da variável que contém a URI é 'PATH_INFO'.
No PHP 8 o nome da variável que contém a URI é 'REQUEST_URI'.

A ideia é que as URI referenciem um controlador, e ele será responsável por
escolher o que será exibido como resultado. A ideia agora é criar nas classes
controladoras um método que processa a requisição e que retorna o HTML.

O MVC apresentado no curso tem alguns acréscimos antes de acessar o controller:
    Browser: que solicita recursos ao web server.
    Web Server: quem responde ao browser, após os retornos dos controllers.
    Routes: mapeia uma URI a um controlador.
    Dispatcher: redireciona as requisições aos controllers, usando routes.

O PHP tem três variáveis globais que podem ser usadas para guardar os dados
das requisições HTTP: $_GET, $_POST ou $_REQUEST (que busca os dados, 
independente de o método ser GET ou POST).

A função filter_input serve para filtrar dados da requisição. Os parâmetros são:
    1)  Tipo: no caso, vai filtrar de INPUT_POST;
    2)  Nome da variável: no exemplo, 'descricao';
    3)  Filtro: no caso, FILTER_SANITIZE_STRING (que está deprecado no PHP 8).
        Há outros filtros (FILTER_VALIDATE_INT).

Para remover HTML, recomenda-se substituir a função filter_input pela função 
htmlspecialchars, pois o filtro FILTER_SANITIZE_STRING está deprecado no PHP 8.

A função filter_var é semelhante à filter_input, mas é usada para variáveis ao
invés de requisições GET ou POST.

O código PHP pode adicionar cabeçalhos à resposta HTTP. É útil para 
redirecionar requisições, por exemplo. A sintaxe no PHP é: 
    header($string); 
    Ex.: header('Location: /listar-cursos');// Já basta pra redirecionar.

A sintaxe completa da função header seria:
    header($string, $replace, $http_response_code);

    Onde:
        $string = Conteúdo do cabeçalho.
        $replace = Se verdadeiro, substitui o cabeçalho original.
        $http_response_code = código HTTP usado na resposta.

Nota: ao redirecionar a requisição, a resposta da página atual não é exibida.

*******************************************************************************
Sim, um arquivo PHP isolado pode ter retorno! Ver o config/routes.php.
Daí, o "require 'config/routes.php" pode ser usado para setar uma variável:

    $rotas = require __DIR__ . '/../config/routes.php';

Sim, você pode instanciar uma classe a partir de uma variável! Se o conteúdo da
variável for uma classe, basta substituir o nome da classe pela variável:
    
    $controlador = new $classeControladora();

*******************************************************************************

A função http_response_code modifica o código HTTP da resposta.
